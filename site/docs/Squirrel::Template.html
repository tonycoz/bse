<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Squirrel::Template - simple templating system</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@localhost" />
</head>

<body style="background-color: white">


<!-- INDEX BEGIN -->
<div name="index">
<p><a name="__index__"></a></p>

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#synopsis">SYNOPSIS</a></li>
	<li><a href="#description">DESCRIPTION</a></li>
	<li><a href="#methods">METHODS</a></li>
	<li><a href="#template_syntax">TEMPLATE SYNTAX</a></li>
	<li><a href="#wrapping">WRAPPING</a></li>
	<li><a href="#tag_evaluation">TAG EVALUATION</a></li>
	<ul>

		<li><a href="#simple_tag_evaluation">Simple tag evaluation</a></li>
		<li><a href="#conditional_tag_evaluation">Conditional tag evaluation</a></li>
		<li><a href="#iterator_tag_evaluation">Iterator tag evaluation</a></li>
	</ul>

	<li><a href="#special_actions">SPECIAL ACTIONS</a></li>
	<li><a href="#see_also">SEE ALSO</a></li>
	<li><a href="#history">HISTORY</a></li>
</ul>

<hr name="index" />
</div>
<!-- INDEX END -->

<p>
</p>
<h1><a name="name">NAME</a></h1>
<pre>
  Squirrel::Template - simple templating system</pre>
<p>
</p>
<hr />
<h1><a name="synopsis">SYNOPSIS</a></h1>
<pre>
  use Squirrel::Template;
  my $templater = Squirrel::Template-&gt;new(template_dir =&gt; $some_dir);
  my $result = $templater-&gt;show_page($base, $filename, \%acts, undef, $alt);
  my $result = $templater-&gt;replace_template($text, \%acts, undef, $display_name);
  my @errors = $templater-&gt;errors;
  my @args = $templater-&gt;get_parms($args, \%acts, $keep_unknown)</pre>
<p>
</p>
<hr />
<h1><a name="description">DESCRIPTION</a></h1>
<p>BSE's template engine.</p>
<p>
</p>
<hr />
<h1><a name="methods">METHODS</a></h1>
<dl>
<dt><strong><a name="new" class="item"><code>new()</code></a></strong></dt>

<dd>
<pre>
  $templater = Squirrel::Template-&gt;new(%opts);</pre>
<p>Create a new templating object.</p>
<p>Possible options are:</p>
<dl>
<dt><strong><a name="verbose" class="item">verbose</a></strong></dt>

<dd>
<p>If a tag isn't found in the actions then it is replaced with an error
message rather than being left in place.</p>
</dd>
<dt><strong><a name="template_dir" class="item">template_dir</a></strong></dt>

<dd>
<p>Used to find wrapper and include templates.  See <em>WRAPPING</em> below.
This can be either a scalar, or a reference to an array of locations
to search for the wrapper.</p>
</dd>
<dt><strong><a name="utf8" class="item">utf8</a></strong></dt>

<dd>
<p>If this is true then the template engine works in unicode internally.
Template files are read into memory using the charecter set specified
by <a href="#charset"><code>charset</code></a>.</p>
</dd>
<dt><strong><a name="charset" class="item">charset</a></strong></dt>

<dd>
<p>Ignored unless <a href="#utf8"><code>utf8</code></a> is true.  Specifies the character encoding used
by template files.  Defaults to <code>&quot;utf-8&quot;</code>.</p>
</dd>
<dt><strong><a name="cache" class="item">cache</a></strong></dt>

<dd>
<p>A BSE::Cache object to use for caching compiled templates.  Note that
templates are currently only cached by filename.</p>
</dd>
</dl>
</dd>
<dt><strong><a name="show_page" class="item"><code>show_page()</code></a></strong></dt>

<dd>
<pre>
  $text = $templ-&gt;show_page($base, $template, \%acts, $iter)</pre>
<p>Performs template replacement on the text from the file $template in
directory $base.</p>
</dd>
<dt><strong><a name="replace_template" class="item"><code>replace_template()</code></a></strong></dt>

<dd>
<pre>
  $text = $templ-&gt;replace_template($intext, \%acts, $iter, $name)</pre>
<p>Performs template replacement on <code>$intext</code> using the tags in
<code>%acts</code>.  <code>$iter</code> is accepted only for backward compatibility and it
no longer used.  Errors are reported as if <code>$intext</code> had been read
from a file called <code>$name</code>.</p>
</dd>
<dt><strong><a name="errors" class="item"><code>errors()</code></a></strong></dt>

<dd>
<p>Return errors from the last <a href="#show_page"><code>show_page()</code></a> or <a href="#replace_template"><code>replace_template()</code></a>.</p>
<p>This can include:</p>
<ul>
<li>
<p>tokenization errors - an unknown token was found in the template</p>
</li>
<li>
<p>parsing errors - mismatched if/eif, etc</p>
</li>
<li>
<p>processing errors - die from tag handlers, etc</p>
</li>
<li>
<p>file errors - missing include or wrap files, and recursion from those.</p>
</li>
</ul>
<p>Returns a list of error tokens, each of which is an array reference
with:</p>
<ul>
<li>
<p>The text &quot;error&quot;.</p>
</li>
<li>
<p>An template text that caused the error.  This may be blank some cases.</p>
</li>
<li>
<p>The line number.</p>
</li>
<li>
<p>The filename.  If you called <a href="#replace_template"><code>replace_template()</code></a> this will be the
<code>$name</code> supplied to <a href="#replace_template"><code>replace_template()</code></a>.</p>
</li>
<li>
<p>An error message.</p>
</li>
</ul>
</dd>
<dt><strong><a name="get_parms" class="item"><code>get_parms()</code></a></strong></dt>

<dd>
<pre>
  my @args = get_parms($args, $acts, $keep_unknown)</pre>
<p>Does simple and stupid processing of <code>$args</code> parsing it for a list of
arguments.</p>
<p>Possible arguments that are parsed are:</p>
<ul>
<li>
<p><code>[</code><em>tagname</em> <em>arguments</em><code>]</code> - return the results of calling the
specified tag.  Only a limited amount of nesting is parsed.</p>
</li>
<li>
<p><code>&quot;</code><em>text</em><code>&quot;</code> - quoted text.  No escaping is done on the text.</p>
</li>
<li>
<p><em>text</em> - plain text not containing any <code>[</code> or <code>]</code>.</p>
</li>
</ul>
<p>Returns a list of parsed arguments.</p>
<p>If <em>tagname</em> in <code>$args</code> isn't defined, dies with an <code>ENOIMPL\n</code>
message.</p>
</dd>
</dl>
<p>
</p>
<hr />
<h1><a name="template_syntax">TEMPLATE SYNTAX</a></h1>
<p>In general, if the tag has no definition the original tag directive is
left in place.  If the tag has sub-components (like <code>if</code> or
<code>iterate</code>) tag replacement is done on the sub-components.</p>
<p>Directives available in templates:</p>
<ul>
<li>
<p><code>&lt;: name args :&gt;</code></p>
<p>Replaced with the value of the tag.  See <a href="#simple_tag_evaluation">Simple tag evaluation</a>.</p>
</li>
<li>
<p><code>&lt;: iterator begin name args :&gt; text &lt;: iterator separator name :&gt; separator &lt;: iterator end name :&gt;</code></p>
<p><code>&lt;: iterator begin name args :&gt; text &lt;: iterator end name :&gt;</code></p>
<p>Replaced with repeated templating of <em>text</em> separated by <em>separator</em>.</p>
<p>See <a href="#iterator_tag_evaluation">Iterator tag evaluation</a>.</p>
</li>
<li>
<p><code>&lt;: ifName args :&gt; true &lt;: or :&gt; false &lt;: eif :&gt;</code></p>
<p><code>&lt;: if Name args :&gt; true &lt;: or Name :&gt; false &lt;: eif Name :&gt;</code></p>
<p>Emits <em>true</em> if the tag evaluates to a true value, otherwise the
<em>false</em> text.  See <a href="#conditional_tag_evaluation">Conditional tag evaluation</a>.</p>
<p>Note that only the <code>if</code> now requires the <code>Name</code>.  The <code>or</code> and
<code>eif</code> may include the name, but it is not required.  If the <code>Name</code>
is supplied it must match the <code>if</code> <code>Name</code> or an error will be
returned.</p>
</li>
<li>
<p><code>&lt;: with begin name args :&gt; replaced &lt;: with end name :&gt;</code></p>
<p>Calls <code>$acts-&gt;{&quot;with_name&quot;}-&gt;($args, $replaced, &quot;&quot;, \%acts,
$name, $templaer)</code> where <code>$replaced</code> is the processed text and
inserts that.</p>
</dd>
<dt><strong><a name="your_comment" class="item">&lt;: # <em>your comment</em> :&gt;</a></strong></dt>

<dd>
<p>A comment, not included in the output.</p>
</dd>
<dt><strong><a name="switch_case_name_optional_args_content_endswitch" class="item">&lt;:switch:&gt;&lt;:case <em>Name</em> <em>optional-args</em> :&gt;<em>content</em> ... &lt;:endswitch:&gt;</a></strong></dt>

<dd>
<p>Replaced with the first matching conditional where <code>&lt;:case Name
optional-args :&gt;</code> is treated like an <code>if</code>.</p>
<p>A <code>&lt;:case default:&gt;</code> is always true.</p>
</li>
<li>
<p><code>&lt;: include filename options :&gt;</code></p>
<p>Replaced with the content of the supplied filename.</p>
<p>If the file <em>filename</em> is not found, this results in an error being
inserted (and reported via <a href="#errors">errors()</a>) unless <em>options</em> contains
<code>optional</code>.</p>
<p>No more than 10 levels of include can be nested.</p>
</li>
</ul>
<p>
</p>
<hr />
<h1><a name="wrapping">WRAPPING</a></h1>
<p>If you define the template_dir option when you create your templating
object, then a mechnism to wrap the current template with another is
enabled.</p>
<p>For the wrapping to occur:</p>
<ul>
<li>
<p>The template specified in the call to <a href="#replace_template"><code>replace_template()</code></a> or
<a href="#show_page"><code>show_page()</code></a> needs to start with:</p>
<p>&lt;: wrap <em>templatename</em> :&gt;</p>
<p>or:</p>
<p>&lt;: wrap <em>templatename</em> <em>name</em> =&gt; <em>value</em>, ... :&gt;</p>
</li>
<li>
<p>The template specified in the &lt;: wrap ... :&gt; tag must exist in the
directory specified by the <em>template_dir</em> option.</p>
</li>
<li>
<p>The template specified in the &lt;: wrap ... :&gt; tag must contain a:</p>
<pre>
   &lt;: wrap here :&gt;</pre>
<p>tag.</p>
</li>
</ul>
<p>The current template text is then replaced with the contents of the
template specified by <em>templatename</em>, with the &lt;: wrap here :&gt;
replaced by the original template text.</p>
<p>This is then repeated for the new template text.</p>
<p>
</p>
<hr />
<h1><a name="tag_evaluation">TAG EVALUATION</a></h1>
<p>
</p>
<h2><a name="simple_tag_evaluation">Simple tag evaluation</a></h2>
<p>Tag definitions in <code>%acts</code> can be in any of five forms:</p>
<ul>
<li>
<p>A simple scalar - the value of the scalar is returned.</p>
</li>
<li>
<p>A scalar reference - the referred to scalar is returned.</p>
</li>
<li>
<p>A code reference - the code reference is called as:</p>
<pre>
  $code-&gt;($args, \%acts, $tagname, $templater)</pre>
</li>
<li>
<p>An array reference starting with a code reference, followed by
arguments, eg <code>[ \&amp;tag_sometag, $foo, $bar ]</code>.  This is called
as:</p>
<pre>
  $code-&gt;($foo, $bar, \%acts, $tagname, $templater)</pre>
</li>
<li>
<p>An array reference starting with a scalar, followed by an object or
class name, followed by arguments, eg <code>[ method =&gt; $obj, $foo, $bar
]</code>.  This is called as:</p>
<pre>
  $obj-&gt;$method($foo, $bar, \%acts, $tagname, $templater)</pre>
</li>
</ul>
<p>A warning is produced if the tag returns an undef value.</p>
<p>
</p>
<h2><a name="conditional_tag_evaluation">Conditional tag evaluation</a></h2>
<p>Given a <code>ifSomeName</code>, does <a href="#simple_tag_evaluation">Simple tag evaluation</a> on the
first tag of <code>ifSomeName</code> or <code>someName</code> found.</p>
<p>Unlike simple tag evaluation this does not warn if the result is undef.</p>
<p>
</p>
<h2><a name="iterator_tag_evaluation">Iterator tag evaluation</a></h2>
<p>This uses two members of <code>%acts</code>:</p>
<ul>
<li>
<p><code>iterate_name_reset</code> - called to start iteration.  Optional
but recommended.</p>
</li>
<li>
<p><code>iterate_name</code> - called until it returns false for each
iteration.</p>
</li>
</ul>
<p>Either can be any of:</p>
<ul>
<li>
<p>a code reference - called as:</p>
<pre>
  $code-&gt;($args, \%acts, $name, $templater)</pre>
</li>
<li>
<p>an array reference starting with a code reference:</p>
<pre>
  $arrayref-&gt;[0]-&gt;(@{$arrayref}[1 .. $#$arrayref], \%acts, $name, $templater);</pre>
</li>
<li>
<p>an array reference starting with a scalar:</p>
<pre>
  $arrayref-&gt;[1]-&gt;$method(@{$arrayref}[2 .. $#$arrayref], \%acts, $name, $templater);</pre>
</li>
</ul>
<p>
</p>
<hr />
<h1><a name="special_actions">SPECIAL ACTIONS</a></h1>
<p>So far there's just one:</p>
<dl>
<dt><strong><a name="_format" class="item">_format</a></strong></dt>

<dd>
<p>If the _format action is defined in your $acts then if a function tag
has |text at the end of it then the function is evaluated, and the
resulting text and the text after the | is passed to the format
function.</p>
</dd>
</dl>
<p>
</p>
<hr />
<h1><a name="see_also">SEE ALSO</a></h1>
<p>Squirrel::Row(3p), Squirel::Table(3p)</p>
<p>
</p>
<hr />
<h1><a name="history">HISTORY</a></h1>
<p>Started as a quick hack from seeing the hacky template replacement
done by an employer.</p>
<p>It grew.</p>
<p>Largely rewritten in 2012 to avoid processing the same string a few
hundred times.</p>

</body>

</html>
